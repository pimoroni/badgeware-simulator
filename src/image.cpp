#include "image.hpp"

#include "span.hpp"
#include "brush.hpp"

#include <string.h>
#include <math.h>

using namespace std;



namespace picovector {

  color_brush _default_image_brush(255, 255, 255, 255);

  image::image(int w, int h) : managed_buffer(true), brush(&_default_image_brush) {
    bounds = rect(0, 0, w, h);
    p = (uint32_t *)malloc(sizeof(uint32_t) * w * h);
    _rowstride = w * sizeof(uint32_t);
  }

  image::image(uint32_t *p, int w, int h) : p(p), managed_buffer(false), brush(&_default_image_brush) {
    bounds = rect(0, 0, w, h);    
    _rowstride = w * sizeof(uint32_t);
  }

  image::~image() {
    if(managed_buffer) {
      free(p);
    }
  }

  image image::window(rect r) {
    rect i = bounds.intersection(r);
    image window = image(ptr(r.x, r.y), i.w, i.h);

    // window.bounds = rect(0, 0, i.w, i.h);
    // window.p = ptr(r.x, r.y);
    window._rowstride = _rowstride;
    return window;
  }


  void image::clear() {
    rectangle(bounds);
  }

  void image::blit(image &t, const point &p, int alpha) {
    rect tr(p.x, p.y, bounds.w, bounds.h); // target rect
    tr = tr.intersection(t.bounds); // clip to target image bounds

    if(tr.empty()) {return;}

    int sxo = p.x < 0 ? -p.x : 0;
    int syo = p.y < 0 ? -p.y : 0;

    for(int i = 0; i < tr.h; i++) {
      uint32_t *src = this->ptr(sxo, syo + i);
      uint32_t *dst = t.ptr(tr.x, tr.y + i);
      span_blit_argb8(src, dst, tr.w, alpha);
    }
  }

  void image::blit(image &t, rect r, int alpha) {
    // rect cr = r.intersection(t.bounds); // get clipped target rect
    // if(cr.empty()) {return;}

    // // determine source bounds for clipped area in fp16:16 coordinates
    // int fprw = (bounds.w << 16) / r.w;
    // int fprh = (bounds.h << 16) / r.h;
    // rect sr(
    //   -min(r.x, 0.0f) * fprw,
    //   -min(r.y, 0.0f) * fprh,
    //   cr.w * fprw,
    //   cr.h * fprh
    // );

    // for(int i = 0; i < cr.h; i++) {
    //   int so = (sr.y + (i * fprh)) >> 16;
    //   uint32_t *dst = t.ptr(cr.x, cr.y + i);
    //   span_blit_scale(this->ptr(0, so), dst, sr.x, sr.w, cr.w, alpha);
    // }
  }

  uint32_t* image::ptr(int x, int y) {
    return this->p + x + (y * (this->_rowstride / sizeof(uint32_t)));
  }

  void image::draw(shape *shape) {
    mat3 m;
    render(shape, this, &m, brush);
  }

  void image::rectangle(const rect &r) {
    for(int y = 0; y < r.h; y++) {
      _rspan span(r.x, y, r.w, 255);
      this->brush->render_spans(this, &span, 1);
    }
  }


  void image::circle(const point &p, const int &r) {
    // int sy = max(p.y - r, 0);
    // int ey = min(p.y + r, bounds.h);
    // for(int y = sy; y < ey; y++) {
    //   int w = sqrt((r * r) - ((y - p.y) * (y - p.y)));
    //   int sx = p.x - w;
    //   int ex = p.x + w;
    //   if(ex < 0 || sx >= bounds.h) {continue;}
    //   sx = max(sx, 0);
    //   ex = min(ex, bounds.w);

    //   //printf("c: %d -> %d @ %d\n", sx, ex, y);
    //   span_argb8(ptr(sx, y), ex - sx, c);
    // }
  }

}